# Colors & styles
BOLD="\[\e[1m\]"
RESET_BOLD="\[\e[22m\]"
RED="\[\e[31m\]"
GREEN="\[\e[32m\]"
BLUE="\[\e[34m\]"
BRIGHT_BLUE="\[\e[94m\]"
YELLOW="\[\e[33m\]"
RESET_COLOR="\[\e[0m\]"
RESET="\[\e[0m\]"
CYAN="\[\e[36m\]"
ORANGE="\[\e[38;5;214m\]"
NEONYELLOW="\[\e[38;5;227m\]"

# regular fucking varibales
VERSION="1.2.7a"
DISTRO="$(. /etc/os-release && echo "$PRETTY_NAME")"

# Helper Functions
cpth() {
    echo "${BOLD}${BLUE}\w${RESET_COLOR}${RESET_BOLD}"
}

git_branch() {
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || return
    if [ -n "$branch" ]; then
        [ "${#branch}" -gt 15 ] && branch="${branch:0:12}…"
        echo " \[\e[33m\](${branch})\[\e[0m\]"
    fi
}

venv_prompt() {
    if [ -n "$VIRTUAL_ENV" ]; then
        echo " \[\e[32m\]($(basename "$VIRTUAL_ENV"))\[\e[0m\]"
    fi
}

username_prompt() {
    if [ "$EUID" -eq 0 ]; then
        echo "\[\e[1;31m\]root|\u\[\e[0m\]"
    else
        echo "\u"
    fi
}

prompt_symbol_color() {
    if [ "$USER" = "root" ]; then
        echo "\[\e[32m\]❮*❯"
    else
        echo "\[\e[31m\]❮~❯"
    fi
}

export PS1="${BOLD}${RED}[${ORANGE}@$(username_prompt)${RESET_COLOR}${RED}${BOLD}]${RESET} : ${BOLD}${GREEN}YelloCake${RESET}${NEONYELLOW} ➤ ${BOLD}${CYAN}${DISTRO}${RESET_COLOR} ${BOLD}$(cpth)${BOLD}$(git_branch)${BOLD}$(venv_prompt) $(prompt_symbol_color)${RESET} ${NEONYELLOW}✦${RESET} "

# Welcome message (interactive shells only)
if [[ $- == *i* ]]; then
    echo -e "\e[1m\e[32mWelcome to YelloCake \e[33mv${VERSION}\e[0m"
fi

# Aliases
alias lr='ls -r'
alias ct='cat'
alias n='nano'
alias v='vim'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias p3='python3'
alias p='sudo apt update'
alias cl='clear'
alias ycrc='nano ~/.yellocake'
alias hm='cd $HOME'
alias pwd='echo $PWD'
alias mem='free -h'
alias disk='df -h'
alias ip='curl ipconfig.me'
alias top='htop'
alias psg='ps aux | grep'
alias g='git'
alias gs='git status'
alias ga='git add'
alias gc='git commit -m'
alias gp='git push'
alias gf='git push --force'
alias gl='git log --oneline --graph --decorate'
alias gco='git checkout'
alias tm='date +"%T"'
alias dat='date +"%Y-%m-%d"'
alias tmp='vcgencmd measure_temp'
alias h='history'
alias rd='rmdir'
alias md='mkdir -p'
alias spc='du -sh *'
alias big='ls -lhS | head'
alias f='find . -name'
alias ff='find . -type f -name'
alias please='sudo !!'
alias t='tree -C -L 2'
alias k9='kill -9'
alias vew='less'

bd() {
    local count=${1:-1}   # default to 1 if no argument
    for ((i=0; i<count; i++)); do
        cd ..
    done
}

#===================
#   here starts the chatgpt madness of one-line functions that i was too lazy to code
#===================
# Bash functions
bs() { bash "$@"; }
bsv() { bash --version; }
bsi() { bash -i "$@"; }
bse() { bash -c "$@"; }
bsr() { source "$@"; }
bsx() { bash -x "$@"; }
bsl() { bash -l "$@"; }
bss() { bash --login "$@"; }
bsa() { alias "$@"; }
bsh() { help "$@"; }

# zsh functions
zh() { zsh "$@"; }
zhv() { zsh --version; }
zhi() { zsh -i "$@"; }
zhc() { zsh -c "$@"; }
zhr() { source "$@"; }
zhx() { zsh -x "$@"; }
zhl() { zsh -l "$@"; }
zhs() { zsh --login "$@"; }
zha() { alias "$@"; }
zhf() { functions "$@"; }

# fish functions
fh() { fish "$@"; }
fhv() { fish --version; }
fhi() { fish -i "$@"; }
fhc() { fish -c "$@"; }
fhr() { source "$@"; }
fhx() { fish --debug="$@"; }
fhl() { fish -l "$@"; }
fhs() { fish --login "$@"; }
fha() { alias "$@"; }
fhf() { functions "$@"; }

# vim functions
vm() { vim "$@"; }
vme() { vim -e "$@"; }
vmx() { vim -x "$@"; }
vmi() { vim -i "$@"; }
vms() { vim -s "$@"; }
vml() { vim -l "$@"; }
vmc() { vim -c "$@"; }
vmd() { vimdiff "$@"; }
vmm() { view "$@"; }
vma() { gvim "$@"; }

# nano functions
nn() { nano "$@"; }
nni() { nano -i "$@"; }
nns() { nano -S "$@"; }
nnw() { nano -w "$@"; }
nnc() { nano -c "$@"; }
nnt() { nano -T "$@"; }
nnv() { nano --version; }
nnd() { nano -d "$@"; }
nnf() { nano -F "$@"; }
nnl() { nano -l "$@"; }

# neovim functions
nv() { nvim "$@"; }
nvi() { nvim -i "$@"; }
nvs() { nvim -s "$@"; }
nvx() { nvim -x "$@"; }
nvl() { nvim -l "$@"; }
nvc() { nvim -c "$@"; }
nvd() { nvimdiff "$@"; }
nvv() { nvim --version; }
nvm() { view "$@"; }
nva() { nvim +"$@"; }

# emacs functions
em() { emacs "$@"; }
emi() { emacs -i "$@"; }
emx() { emacs -Q "$@"; }
emv() { emacs --version; }
emf() { emacs --funcall "$@"; }
emc() { emacs -batch -l "$@"; }
ems() { emacs -script "$@"; }
eml() { emacs -nw "$@"; }
ema() { emacs -daemon "$@"; }
emd() { emacsclient "$@"; }

# git functions
gi() { git "$@"; }
gic() { git clone "$@"; }
gis() { git status "$@"; }
gia() { git add "$@"; }
gicm() { git commit -m "$@"; }
gip() { git push "$@"; }
gif() { git fetch "$@"; }
gipm() { git pull "$@"; }
gib() { git branch "$@"; }
gico() { git checkout "$@"; }

# git-lfs functions
glf() { git lfs "$@"; }
glfi() { git lfs install "$@"; }
glfp() { git lfs pull "$@"; }
glfpush() { git lfs push "$@"; }
glfstatus() { git lfs status "$@"; }
glftrack() { git lfs track "$@"; }
glfuntrack() { git lfs untrack "$@"; }
glfls() { git lfs ls-files "$@"; }
glffetch() { git lfs fetch "$@"; }
glfclone() { git lfs clone "$@"; }

# curl functions
cu() { curl "$@"; }
cuv() { curl --version; }
cui() { curl -I "$@"; }
cux() { curl -X "$@"; }
cup() { curl -P "$@"; }
cuh() { curl -H "$@"; }
cuo() { curl -O "$@"; }
cuol() { curl -OL "$@"; }
cuL() { curl -L "$@"; }
cuf() { curl -F "$@"; }

# wget functions
wg() { wget "$@"; }
wgv() { wget --version; }
wgi() { wget -i "$@"; }
wgc() { wget -c "$@"; }
wgp() { wget -P "$@"; }
wgn() { wget -N "$@"; }
wgl() { wget -L "$@"; }
wgu() { wget --user="$1" --password="$2" "$3"; }
wgo() { wget -O "$@"; }
wgd() { wget -r -np "$@"; }

# unzip functions
un() { unzip "$@"; }
unu() { unzip -u "$@"; }
unl() { unzip -l "$@"; }
unx() { unzip -x "$@"; }
unv() { unzip -v; }
unc() { unzip -c "$@"; }
unt() { unzip -t "$@"; }
unuq() { unzip -q "$@"; }
unp() { unzip -p "$@"; }
unf() { unzip -F "$@"; }

# zip functions
zp() { zip "$@"; }
zpu() { zip -u "$@"; }
zpl() { zip -l "$@"; }
zpx() { zip -x "$@"; }
zpv() { zip -v; }
zpf() { zip -F "$@"; }
zpt() { zip -T "$@"; }
zpc() { zip -c "$@"; }
zpr() { zip -r "$@"; }
zpn() { zip -n "$@"; }

# tar functions
tr() { tar "$@"; }
trx() { tar -xvf "$@"; }
trc() { tar -cvf "$@"; }
trt() { tar -tf "$@"; }
trz() { tar -czf "$@"; }
tru() { tar -xzf "$@"; }
trj() { tar -xjf "$@"; }
trxv() { tar -xvzf "$@"; }
trv() { tar -v "$@"; }
trf() { tar -f "$@"; }

# gzip functions
gz() { gzip "$@"; }
gzd() { gzip -d "$@"; }
gzt() { gzip -t "$@"; }
gzv() { gzip --version; }
gzc() { gzip -c "$@"; }
gzl() { gzip -l "$@"; }
gzk() { gzip -k "$@"; }
gzf() { gzip -f "$@"; }
gzu() { gunzip "$@"; }
gzx() { gzip -x "$@"; }

# bzip2 functions
bz() { bzip2 "$@"; }
bzd() { bzip2 -d "$@"; }
bzt() { bzip2 -t "$@"; }
bzv() { bzip2 --version; }
bzc() { bzip2 -c "$@"; }
bzk() { bzip2 -k "$@"; }
bzf() { bzip2 -f "$@"; }
bzu() { bunzip2 "$@"; }
bzx() { bzip2 -x "$@"; }
bzl() { bzip2 -l "$@"; }

# xz-utils functions
xz() { xz "$@"; }
xzd() { xz -d "$@"; }
xzt() { xz -t "$@"; }
xzv() { xz --version; }
xzc() { xz -c "$@"; }
xzk() { xz -k "$@"; }
xzf() { xz -f "$@"; }
xzu() { unxz "$@"; }
xzl() { xz -l "$@"; }
xzx() { xz -x "$@"; }

# htop functions
ht() { htop "$@"; }
htv() { htop --version; }
hti() { htop -d "$@"; }
hts() { htop -s "$@"; }
htc() { htop -C "$@"; }
htu() { htop -u "$@"; }
htf() { htop -f "$@"; }
htl() { htop -l "$@"; }
htm() { htop -m "$@"; }
htr() { htop -r "$@"; }

# ncdu functions
nd() { ncdu "$@"; }
ndv() { ncdu --version; }
ndx() { ncdu -x "$@"; }
ndq() { ncdu -q "$@"; }
ndr() { ncdu -r "$@"; }
ndf() { ncdu -f "$@"; }
ndl() { ncdu -l "$@"; }
ndu() { ncdu -u "$@"; }
nds() { ncdu -s "$@"; }
ndt() { ncdu -t "$@"; }

# tree functions
trt() { tree "$@"; }
trtv() { tree --version; }
trtl() { tree -L "$@"; }
trta() { tree -a "$@"; }
trtc() { tree -C "$@"; }
trtf() { tree -f "$@"; }
trtp() { tree -P "$@"; }
trtx() { tree -x "$@"; }
trtd() { tree -d "$@"; }
trts() { tree -s "$@"; }

# lsof functions
lsf() { lsof "$@"; }
lsfv() { lsof -v; }
lsfi() { lsof -i "$@"; }
lsft() { lsof -t "$@"; }
lsfn() { lsof -n "$@"; }
lsfp() { lsof -p "$@"; }
lsfu() { lsof -u "$@"; }
lsfd() { lsof -d "$@"; }
lsfc() { lsof -c "$@"; }
lsfl() { lsof -l "$@"; }

# iproute2 / networking / http functions
ipr() { ip "$@"; }
iprv() { ip -V; }
ipra() { ip addr "$@"; }
iprli() { ip link "$@"; }
iprr() { ip route "$@"; }
iprne() { ip neighbor "$@"; }
iprns() { ip netns "$@"; }
iprml() { ip maddr "$@"; }
iprt() { ip tuntap "$@"; }
iprti() { ip tunnel "$@"; }

pf() { ping "$@"; }
pv() { ping -V; }
pc() { ping -c "$@"; }
pi() { ping -i "$@"; }
pt() { ping -t "$@"; }
pw() { ping -W "$@"; }
ps() { ping -s "$@"; }
pl() { ping -l "$@"; }
pp() { ping -p "$@"; }
p6() { ping6 "$@"; }
#===========================
# chatgpt bullshit ends here. if you have any complaints, consult openai
# if, however, you have complaints about following code... fuck off ig
#===========================


# Add this to your ~/.YelloCake or ~/.bashrc
# if you add to ~/.YelloCake, then this won't work unless you source ~/.YelloCake in your ~/.bashrc file

# Functions


# python functions
pips() {
    pip show "$@"
}
pist() {
    pip install "$@"
}

pup() {
    pip upgrade "$@"
}

pun() {
    pip uninstall "$@"
}

pfre() {
    pip freeze
}

pychk() { python3 -c "import $1; print('$1 is installed')" 2>/dev/null || echo "$1 not installed"; }

ist() { # fuck
    if sudo apt install "$@"; then
        echo "$@ installed as $USER"
    else
        echo "Failed to install $@ ✗
        Retrying with sudo"
        if sudo apt install "$@"; then
            echo  "$@ installed correctly as sudo ✓"
    fi
}

r()   { sudo apt remove "$@"; }

u()   { sudo apt update; }

#file system functions


tch() { # create file and optionally edit with -n flag
    edit=false
    for arg in "$@"; do
        [ "$arg" = "-n" ] && edit=true || file="$arg"
    done
    [ -z "$file" ] && { echo "Usage: mytouch <file> [-n]"; return 1; }
    touch "$file"
    $edit && nano "$file"
}

mcd() {
    mkdir -p "$1" && cd "$1"
}

cod() {
    touch "$1" && nano "$1"
}

er() {
    if [ -f "$1" ]; then
        grep -i "error" "$1" || echo "No errors found in $1"
    else
        echo "File not found!"
    fi
}

spy() {
    if [ -f "$1" ]; then
        while IFS= read -r line; do
            echo "$line"
            sleep 0.05
        done < "$1"
    else
        echo "File not found!"
    fi
}

bkup() {
    cp "$1" "${1}.bak"
    echo "Backup created: ${1}.bak"
}

fcd() {
    # Add folder if -a flag is used
    if [ "$1" = "-a" ] && [ -n "$2" ]; then
        echo "$2" >> "$HOME/.YelloCake_folds"
        echo "Added $2 to favorites."
        return
    fi

    # No argument: list all folders
    if [ -z "$1" ]; then
        cat "$HOME/.YelloCake_folds"
        return
    fi

    # Jump to folder by name match
    local target
    target=$(grep -i "$1" "$HOME/.YelloCake_folds" | head -n1)
    if [ -n "$target" ]; then
        cd "$target" || echo "Failed to cd to $target"
    else
        echo "No folder matching '$1' found."
    fi
}

_fcd_completions() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=($(compgen -W "$(cat "$HOME/.YelloCake_folds" | xargs -n1 basename)" -- "$cur"))
}

complete -F _fcd_completions fcd

fpwd() {
    local dir="$PWD"
    if [ -z "$dir" ]; then
        echo "Usage: fav_add <folder_path>"
        return 1
    fi

    if [ ! -d "$dir" ]; then
        echo "Directory '$dir' does not exist!"
        return 1
    fi

    # Make sure favorites file exists
    FAV_FILE="$HOME/.YelloCake_folds"
    touch "$FAV_FILE"

    # Avoid duplicates
    if grep -qxF "$dir" "$FAV_FILE"; then
        echo "'$dir' is already in favorites."
    else
        echo "$dir" >> "$FAV_FILE"
        echo "Added '$dir' to favorites."
    fi
}
fav() {
    local dir="$1"
    if [ -z "$dir" ]; then
        echo "Usage: fav <folder_path>"
        return 1
    fi

    if [ ! -d "$dir" ]; then
        echo "Directory '$dir' does not exist"
        return 1
    fi

    # Make sure favorites file exists
    FAV_FILE="$HOME/.YelloCake_folds"
    touch "$FAV_FILE"

    # Avoid duplicates
    if grep -qxF "$dir" "$FAV_FILE"; then
        echo "'$dir' is already in favorites."
    else
        echo "$dir" >> "$FAV_FILE"
        echo "Added '$dir' to favorites."
    fi
}

favlst() {
    FAV_FILE="$HOME/.YelloCake_folds"
    if [ ! -f "$FAV_FILE" ]; then
        echo "No favorites found."
        return
    fi

    echo "Favorite Folders:"
    nl -w2 -s'. ' "$FAV_FILE"
}





# http/network functions

up() {
    if [ -z "$1" ]; then
        echo "Usage: up <url>"
        return 1
    fi

    if curl -s --head --fail "$1" >/dev/null 2>&1; then
        echo "$1 up ✓"
    else
        echo "$1 down ✗"
    fi
}


wthr() {
    curl -s "https://wttr.in/${1:-}" | head -n 7
}

myip() {
    curl -s https://ipinfo.io | grep -E 'ip|city|region|country|org'
}

uptime() { uptime -p; }

sz() {
    du -sh "$@" 2>/dev/null
}

png() {
    for host in "$@"; do
        echo "Pinging $host..."
        ping -c 2 "$host"
    done
}

prt() {
    sudo netstat -tulnp | grep LISTEN
}

nfo() {

    if [ "$OS_NAME" = "Linux" ] || [ "$OS_NAME" = "Darwin" ]; then
        echo "Interfaces:"
        ip addr show 2>/dev/null || ifconfig

        echo -e "\nDefault Gateway:"
        ip route 2>/dev/null | grep default || netstat -rn | grep default

        echo -e "\nDNS Servers:"
        grep 'nameserver' /etc/resolv.conf

        echo -e "\nPublic IP:"
        curl -s https://ipinfo.io/ip
    else
        echo "Network info not supported for $OS_NAME"
    fi
}


# system functions

ram() {
    ps aux --sort=-%mem | head -n 10
}

cpu() {
    ps aux --sort=-%cpu | head -n 10
}

extr() {
    inst=""
    for pkg in tar bzip2 xz unzip rar unrar p7zip-full gzip lzip; do
        if command -v $pkg &>/dev/null; then
            echo "$pkg ✓ installed"
        else
            echo "$pkg ✗ missing"
            inst="$inst $pkg"
        fi
    done
    sudo apt install $inst
    inst=""
    if [ -f "$1" ]; then

        case "$1" in
            *.tar.gz) tar xzf "$1" ;;
            *.tar.bz2) tar xjf "$1" ;;
            *.tar.xz) tar xf "$1" ;;
            *.zip) unzip "$1" ;;
            *.rar) unrar x "$1" ;;
            *.7z) 7z x "$1" ;;
            *) echo "extractfile: Cannot extract '$1'" ;;
        esac
    else
        echo "extractfile: '$1' is not a valid file"
    fi
}

dsk() {
    echo "Storage Usage:"
    df -h --total -x tmpfs -x devtmpfs | awk '
    BEGIN { total=0; used=0; avail=0; }
    /^Filesystem/ { next }
    /total/ { print "Total: " $2 "\tUsed: " $3 "\tAvailable: " $4; exit }
    '
}
