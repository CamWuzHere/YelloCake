# Colors & styles
BOLD="\[\e[1m\]"
RESET_BOLD="\[\e[22m\]"
RED="\[\e[31m\]"
GREEN="\[\e[32m\]"
BLUE="\[\e[34m\]"
BRIGHT_BLUE="\[\e[94m\]"
YELLOW="\[\e[33m\]"
RESET_COLOR="\[\e[0m\]"
RESET="\[\e[0m\]"
CYAN="\[\e[36m\]"
ORANGE="\[\e[38;5;214m\]"
NEONYELLOW="\[\e[38;5;227m\]"

# regular fucking varibales
VERSION="1.2.7a"
DISTRO="$(. /etc/os-release && echo "$PRETTY_NAME")"

# Helper Functions
cpth() {
    echo "${BOLD}${BLUE}\w${RESET_COLOR}${RESET_BOLD}"
}

git_branch() {
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || return
    if [ -n "$branch" ]; then
        [ "${#branch}" -gt 15 ] && branch="${branch:0:12}…"
        echo " \[\e[33m\](${branch})\[\e[0m\]"
    fi
}

venv_prompt() {
    if [ -n "$VIRTUAL_ENV" ]; then
        echo " \[\e[32m\]($(basename "$VIRTUAL_ENV"))\[\e[0m\]"
    fi
}

username_prompt() {
    if [ "$EUID" -eq 0 ]; then
        echo "\[\e[1;31m\]root|\u\[\e[0m\]"
    else
        echo "\u"
    fi
}

prompt_symbol_color() {
    if [ "$USER" = "root" ]; then
        echo "\[\e[32m\]❮*❯"
    else
        echo "\[\e[31m\]❮~❯"
    fi
}

export PS1="${BOLD}${RED}[${ORANGE}@$(username_prompt)${RESET_COLOR}${RED}${BOLD}]${RESET} : ${BOLD}${GREEN}YelloCake${RESET}${NEONYELLOW} ➤ ${BOLD}${CYAN}${DISTRO}${RESET_COLOR} ${BOLD}$(cpth)${BOLD}$(git_branch)${BOLD}$(venv_prompt) $(prompt_symbol_color)${RESET} ${NEONYELLOW}✦${RESET} "

# Welcome message (interactive shells only)
if [[ $- == *i* ]]; then
    echo -e "\e[1m\e[32mWelcome to YelloCake \e[33mv${VERSION}\e[0m"
fi

# Aliases
alias lr='ls -r'
alias ct='cat'
alias n='nano'
alias v='vim'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias p3='python3'
alias p='sudo apt update'
alias cl='clear'
alias ycrc='nano ~/.yellocake'
alias hm='cd $HOME'
alias pwd='echo $PWD'
alias mem='free -h'
alias disk='df -h'
alias ip='curl ipconfig.me'
alias top='htop'
alias psg='ps aux | grep'
alias g='git'
alias gs='git status'
alias ga='git add'
alias gc='git commit -m'
alias gp='git push'
alias gf='git push --force'
alias gl='git log --oneline --graph --decorate'
alias gco='git checkout'
alias tm='date +"%T"'
alias dat='date +"%Y-%m-%d"'
alias tmp='vcgencmd measure_temp'
alias h='history'
alias rd='rmdir'
alias md='mkdir -p'
alias spc='du -sh *'
alias big='ls -lhS | head'
alias f='find . -name'
alias ff='find . -type f -name'
alias please='sudo !!'
alias t='tree -C -L 2'
alias k9='kill -9'
alias vew='less'

# Bash functions
bs() { bash "$@"; }
bsv() { bash --version; }
bsi() { bash -i "$@"; }
bse() { bash -c "$@"; }
bsr() { source "$@"; }
bsx() { bash -x "$@"; }
bsl() { bash -l "$@"; }
bss() { bash --login "$@"; }
bsa() { alias "$@"; }
bsh() { help "$@"; }

# zsh functions
zh() { zsh "$@"; }
zhv() { zsh --version; }
zhi() { zsh -i "$@"; }
zhc() { zsh -c "$@"; }
zhr() { source "$@"; }
zhx() { zsh -x "$@"; }
zhl() { zsh -l "$@"; }
zhs() { zsh --login "$@"; }
zha() { alias "$@"; }
zhf() { functions "$@"; }

# fish functions
fh() { fish "$@"; }
fhv() { fish --version; }
fhi() { fish -i "$@"; }
fhc() { fish -c "$@"; }
fhr() { source "$@"; }
fhx() { fish --debug="$@"; }
fhl() { fish -l "$@"; }
fhs() { fish --login "$@"; }
fha() { alias "$@"; }
fhf() { functions "$@"; }

# vim functions
vm() { vim "$@"; }
vme() { vim -e "$@"; }
vmx() { vim -x "$@"; }
vmi() { vim -i "$@"; }
vms() { vim -s "$@"; }
vml() { vim -l "$@"; }
vmc() { vim -c "$@"; }
vmd() { vimdiff "$@"; }
vmm() { view "$@"; }
vma() { gvim "$@"; }

# nano functions
nn() { nano "$@"; }
nni() { nano -i "$@"; }
nns() { nano -S "$@"; }
nnw() { nano -w "$@"; }
nnc() { nano -c "$@"; }
nnt() { nano -T "$@"; }
nnv() { nano --version; }
nnd() { nano -d "$@"; }
nnf() { nano -F "$@"; }
nnl() { nano -l "$@"; }

# neovim functions
nv() { nvim "$@"; }
nvi() { nvim -i "$@"; }
nvs() { nvim -s "$@"; }
nvx() { nvim -x "$@"; }
nvl() { nvim -l "$@"; }
nvc() { nvim -c "$@"; }
nvd() { nvimdiff "$@"; }
nvv() { nvim --version; }
nvm() { view "$@"; }
nva() { nvim +"$@"; }

# emacs functions
em() { emacs "$@"; }
emi() { emacs -i "$@"; }
emx() { emacs -Q "$@"; }
emv() { emacs --version; }
emf() { emacs --funcall "$@"; }
emc() { emacs -batch -l "$@"; }
ems() { emacs -script "$@"; }
eml() { emacs -nw "$@"; }
ema() { emacs -daemon "$@"; }
emd() { emacsclient "$@"; }

# git functions
gi() { git "$@"; }
gic() { git clone "$@"; }
gis() { git status "$@"; }
gia() { git add "$@"; }
gicm() { git commit -m "$@"; }
gip() { git push "$@"; }
gif() { git fetch "$@"; }
gipm() { git pull "$@"; }
gib() { git branch "$@"; }
gico() { git checkout "$@"; }

# git-lfs functions
glf() { git lfs "$@"; }
glfi() { git lfs install "$@"; }
glfp() { git lfs pull "$@"; }
glfpush() { git lfs push "$@"; }
glfstatus() { git lfs status "$@"; }
glftrack() { git lfs track "$@"; }
glfuntrack() { git lfs untrack "$@"; }
glfls() { git lfs ls-files "$@"; }
glffetch() { git lfs fetch "$@"; }
glfclone() { git lfs clone "$@"; }

# curl functions
cu() { curl "$@"; }
cuv() { curl --version; }
cui() { curl -I "$@"; }
cux() { curl -X "$@"; }
cup() { curl -P "$@"; }
cuh() { curl -H "$@"; }
cuo() { curl -O "$@"; }
cuol() { curl -OL "$@"; }
cuL() { curl -L "$@"; }
cuf() { curl -F "$@"; }

# wget functions
wg() { wget "$@"; }
wgv() { wget --version; }
wgi() { wget -i "$@"; }
wgc() { wget -c "$@"; }
wgp() { wget -P "$@"; }
wgn() { wget -N "$@"; }
wgl() { wget -L "$@"; }
wgu() { wget --user="$1" --password="$2" "$3"; }
wgo() { wget -O "$@"; }
wgd() { wget -r -np "$@"; }

# unzip functions
un() { unzip "$@"; }
unu() { unzip -u "$@"; }
unl() { unzip -l "$@"; }
unx() { unzip -x "$@"; }
unv() { unzip -v; }
unc() { unzip -c "$@"; }
unt() { unzip -t "$@"; }
unuq() { unzip -q "$@"; }
unp() { unzip -p "$@"; }
unf() { unzip -F "$@"; }

# zip functions
zp() { zip "$@"; }
zpu() { zip -u "$@"; }
zpl() { zip -l "$@"; }
zpx() { zip -x "$@"; }
zpv() { zip -v; }
zpf() { zip -F "$@"; }
zpt() { zip -T "$@"; }
zpc() { zip -c "$@"; }
zpr() { zip -r "$@"; }
zpn() { zip -n "$@"; }

# tar functions
tr() { tar "$@"; }
trx() { tar -xvf "$@"; }
trc() { tar -cvf "$@"; }
trt() { tar -tf "$@"; }
trz() { tar -czf "$@"; }
tru() { tar -xzf "$@"; }
trj() { tar -xjf "$@"; }
trxv() { tar -xvzf "$@"; }
trv() { tar -v "$@"; }
trf() { tar -f "$@"; }

# gzip functions
gz() { gzip "$@"; }
gzd() { gzip -d "$@"; }
gzt() { gzip -t "$@"; }
gzv() { gzip --version; }
gzc() { gzip -c "$@"; }
gzl() { gzip -l "$@"; }
gzk() { gzip -k "$@"; }
gzf() { gzip -f "$@"; }
gzu() { gunzip "$@"; }
gzx() { gzip -x "$@"; }

# bzip2 functions
bz() { bzip2 "$@"; }
bzd() { bzip2 -d "$@"; }
bzt() { bzip2 -t "$@"; }
bzv() { bzip2 --version; }
bzc() { bzip2 -c "$@"; }
bzk() { bzip2 -k "$@"; }
bzf() { bzip2 -f "$@"; }
bzu() { bunzip2 "$@"; }
bzx() { bzip2 -x "$@"; }
bzl() { bzip2 -l "$@"; }

# xz-utils functions
xz() { xz "$@"; }
xzd() { xz -d "$@"; }
xzt() { xz -t "$@"; }
xzv() { xz --version; }
xzc() { xz -c "$@"; }
xzk() { xz -k "$@"; }
xzf() { xz -f "$@"; }
xzu() { unxz "$@"; }
xzl() { xz -l "$@"; }
xzx() { xz -x "$@"; }

# htop functions
ht() { htop "$@"; }
htv() { htop --version; }
hti() { htop -d "$@"; }
hts() { htop -s "$@"; }
htc() { htop -C "$@"; }
htu() { htop -u "$@"; }
htf() { htop -f "$@"; }
htl() { htop -l "$@"; }
htm() { htop -m "$@"; }
htr() { htop -r "$@"; }

# ncdu functions
nd() { ncdu "$@"; }
ndv() { ncdu --version; }
ndx() { ncdu -x "$@"; }
ndq() { ncdu -q "$@"; }
ndr() { ncdu -r "$@"; }
ndf() { ncdu -f "$@"; }
ndl() { ncdu -l "$@"; }
ndu() { ncdu -u "$@"; }
nds() { ncdu -s "$@"; }
ndt() { ncdu -t "$@"; }

# tree functions
trt() { tree "$@"; }
trtv() { tree --version; }
trtl() { tree -L "$@"; }
trta() { tree -a "$@"; }
trtc() { tree -C "$@"; }
trtf() { tree -f "$@"; }
trtp() { tree -P "$@"; }
trtx() { tree -x "$@"; }
trtd() { tree -d "$@"; }
trts() { tree -s "$@"; }

# lsof functions
lsf() { lsof "$@"; }
lsfv() { lsof -v; }
lsfi() { lsof -i "$@"; }
lsft() { lsof -t "$@"; }
lsfn() { lsof -n "$@"; }
lsfp() { lsof -p "$@"; }
lsfu() { lsof -u "$@"; }
lsfd() { lsof -d "$@"; }
lsfc() { lsof -c "$@"; }
lsfl() { lsof -l "$@"; }

# iproute2 / networking / http functions
ipr() { ip "$@"; }
iprv() { ip -V; }
ipra() { ip addr "$@"; }
iprli() { ip link "$@"; }
iprr() { ip route "$@"; }
iprne() { ip neighbor "$@"; }
iprns() { ip netns "$@"; }
iprml() { ip maddr "$@"; }
iprt() { ip tuntap "$@"; }
iprti() { ip tunnel "$@"; }

pingf() { ping "$@"; }
pingv() { ping -V; }
pingc() { ping -c "$@"; }
pingi() { ping -i "$@"; }
pingt() { ping -t "$@"; }
pingW() { ping -W "$@"; }
pings() { ping -s "$@"; }
pingl() { ping -l "$@"; }
pingp() { ping -p "$@"; }
pingf6() { ping6 "$@"; }

sprt() {
    HOST="$1"
    START="$2"
    END="$3"
    OUTFILE="$4"

    if [ -z "$HOST" ] || [ -z "$START" ] || [ -z "$END" ] || [ -z "$OUTFILE" ]; then
        echo "Usage: sprt <host> <start_port> <end_port> <output_file>"
        return 1
    fi

    (
        echo "Starting background port scan of $HOST ($START-$END)..." > "$OUTFILE"
        echo "Results will be written to: $OUTFILE"

        MAX_JOBS=200

        _yc_probe_port() {
            PORT=$1
            (echo > /dev/tcp/"$HOST"/"$PORT") >/dev/null 2>&1
            if [ $? -eq 0 ]; then
                echo "OPEN: $PORT" >> "$OUTFILE"
            fi
        }

        CURRENT_JOBS=0
        for ((p=START; p<=END; p++)); do
            _yc_probe_port "$p" &

            ((CURRENT_JOBS++))
            if [ "$CURRENT_JOBS" -ge "$MAX_JOBS" ]; then
                wait
                CURRENT_JOBS=0
            fi
        done

        wait
        echo "Scan complete." >> "$OUTFILE"
    ) &

    echo "Port scan running in background. You can continue using your terminal."
}

up() {
    if [ -z "$1" ]; then
        echo "Usage: up <url>"
        return 1
    fi

    if curl -s --head --fail "$1" >/dev/null 2>&1; then
        echo "$1 up ✓"
    else
        echo "$1 down ✗"
    fi
}

wthr() {
    curl -s "https://wttr.in/${1:-}" | head -n 7
}

myip() {
    curl -s https://ipinfo.io | grep -E 'ip|city|region|country|org'
}

uptime() { uptime -p; }

sz() { du -sh "$@" 2>/dev/null; }

png() {
    for host in "$@"; do
        echo "Pinging $host..."
        ping -c 5 "$host"
    done
}

pup() {
    pip install --upgrade "$@"
}

ycapt() {
    local pkg="$1"
    local version="$2"

    if [ -z "$pkg" ] || [ -z "$version" ]; then
        echo "Usage: ycapt <package> <version>"
        return 1
    fi

    local REPO_DIR="$HOME/my_yellocake_debs"
    local BASE_URL="https://camwuzhere.github.io/YelloCake/debs"

    mkdir -p "$REPO_DIR"

    local deb="${pkg}_${version}_all.deb"
    local url="$BASE_URL/$deb"

    if [ ! -f "$REPO_DIR/$deb" ]; then
        echo "Downloading $deb ..."
        if ! curl -L --fail -o "$REPO_DIR/$deb" "$url"; then
            echo "ERROR: Could not download $url"
            return 1
        fi
        echo "✔ Downloaded"
    else
        echo "✔ Using cached $deb"
    fi

    echo "Regenerating Packages.gz..."
    ( cd "$REPO_DIR" && dpkg-scanpackages . /dev/null | gzip -9c > Packages.gz )
    echo "✔ Packages.gz created"

    echo "Installing $pkg=$version ..."
    sudo apt update
    if ! sudo apt install -y "yellocake_${version}_all.deb"; then
        echo "ERROR: apt could not install ${pkg}=${version}"
        return 1
    fi

    echo "✔ Installed ${pkg} ${version}"
}
